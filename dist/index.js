var ge=Object.create;var M=Object.defineProperty;var we=Object.getOwnPropertyDescriptor;var Se=Object.getOwnPropertyNames;var ye=Object.getPrototypeOf,Pe=Object.prototype.hasOwnProperty;var j=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),Ve=(n,e)=>{for(var t in e)M(n,t,{get:e[t],enumerable:!0})},q=(n,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Se(e))!Pe.call(n,r)&&r!==t&&M(n,r,{get:()=>e[r],enumerable:!(s=we(e,r))||s.enumerable});return n};var A=(n,e,t)=>(t=n!=null?ge(ye(n)):{},q(e||!n||!n.__esModule?M(t,"default",{value:n,enumerable:!0}):t,n)),Ae=n=>q(M({},"__esModule",{value:!0}),n);var ae=j((Vt,ie)=>{"use strict";var oe=Object.getOwnPropertySymbols,De=Object.prototype.hasOwnProperty,ve=Object.prototype.propertyIsEnumerable;function Ee(n){if(n==null)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(n)}function be(){try{if(!Object.assign)return!1;var n=new String("abc");if(n[5]="de",Object.getOwnPropertyNames(n)[0]==="5")return!1;for(var e={},t=0;t<10;t++)e["_"+String.fromCharCode(t)]=t;var s=Object.getOwnPropertyNames(e).map(function(o){return e[o]});if(s.join("")!=="0123456789")return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach(function(o){r[o]=o}),Object.keys(Object.assign({},r)).join("")==="abcdefghijklmnopqrst"}catch{return!1}}ie.exports=be()?Object.assign:function(n,e){for(var t,s=Ee(n),r,o=1;o<arguments.length;o++){t=Object(arguments[o]);for(var c in t)De.call(t,c)&&(s[c]=t[c]);if(oe){r=oe(t);for(var d=0;d<r.length;d++)ve.call(t,r[d])&&(s[r[d]]=t[r[d]])}}return s}});var le=j((At,K)=>{"use strict";K.exports=xe;K.exports.append=de;var Ie=/^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;function de(n,e){if(typeof n!="string")throw new TypeError("header argument is required");if(!e)throw new TypeError("field argument is required");for(var t=Array.isArray(e)?e:ce(String(e)),s=0;s<t.length;s++)if(!Ie.test(t[s]))throw new TypeError("field argument contains an invalid header name");if(n==="*")return n;var r=n,o=ce(n.toLowerCase());if(t.indexOf("*")!==-1||o.indexOf("*")!==-1)return"*";for(var c=0;c<t.length;c++){var d=t[c].toLowerCase();o.indexOf(d)===-1&&(o.push(d),r=r?r+", "+t[c]:t[c])}return r}function ce(n){for(var e=0,t=[],s=0,r=0,o=n.length;r<o;r++)switch(n.charCodeAt(r)){case 32:s===e&&(s=e=r+1);break;case 44:t.push(n.substring(s,e)),s=e=r+1;break;default:e=r+1;break}return t.push(n.substring(s,e)),t}function xe(n,e){if(!n||!n.getHeader||!n.setHeader)throw new TypeError("res argument is required");var t=n.getHeader("Vary")||"",s=Array.isArray(t)?t.join(", "):String(t);(t=de(s,e))&&n.setHeader("Vary",t)}});var pe=j((Dt,me)=>{(function(){"use strict";var n=ae(),e=le(),t={origin:"*",methods:"GET,HEAD,PUT,PATCH,POST,DELETE",preflightContinue:!1,optionsSuccessStatus:204};function s(i){return typeof i=="string"||i instanceof String}function r(i,a){if(Array.isArray(a)){for(var l=0;l<a.length;++l)if(r(i,a[l]))return!0;return!1}else return s(a)?i===a:a instanceof RegExp?a.test(i):!!a}function o(i,a){var l=a.headers.origin,h=[],m;return!i.origin||i.origin==="*"?h.push([{key:"Access-Control-Allow-Origin",value:"*"}]):s(i.origin)?(h.push([{key:"Access-Control-Allow-Origin",value:i.origin}]),h.push([{key:"Vary",value:"Origin"}])):(m=r(l,i.origin),h.push([{key:"Access-Control-Allow-Origin",value:m?l:!1}]),h.push([{key:"Vary",value:"Origin"}])),h}function c(i){var a=i.methods;return a.join&&(a=i.methods.join(",")),{key:"Access-Control-Allow-Methods",value:a}}function d(i){return i.credentials===!0?{key:"Access-Control-Allow-Credentials",value:"true"}:null}function w(i,a){var l=i.allowedHeaders||i.headers,h=[];return l?l.join&&(l=l.join(",")):(l=a.headers["access-control-request-headers"],h.push([{key:"Vary",value:"Access-Control-Request-Headers"}])),l&&l.length&&h.push([{key:"Access-Control-Allow-Headers",value:l}]),h}function y(i){var a=i.exposedHeaders;if(a)a.join&&(a=a.join(","));else return null;return a&&a.length?{key:"Access-Control-Expose-Headers",value:a}:null}function p(i){var a=(typeof i.maxAge=="number"||i.maxAge)&&i.maxAge.toString();return a&&a.length?{key:"Access-Control-Max-Age",value:a}:null}function u(i,a){for(var l=0,h=i.length;l<h;l++){var m=i[l];m&&(Array.isArray(m)?u(m,a):m.key==="Vary"&&m.value?e(a,m.value):m.value&&a.setHeader(m.key,m.value))}}function T(i,a,l,h){var m=[],$=a.method&&a.method.toUpperCase&&a.method.toUpperCase();$==="OPTIONS"?(m.push(o(i,a)),m.push(d(i,a)),m.push(c(i,a)),m.push(w(i,a)),m.push(p(i,a)),m.push(y(i,a)),u(m,l),i.preflightContinue?h():(l.statusCode=i.optionsSuccessStatus,l.setHeader("Content-Length","0"),l.end())):(m.push(o(i,a)),m.push(d(i,a)),m.push(y(i,a)),u(m,l),h())}function P(i){var a=null;return typeof i=="function"?a=i:a=function(l,h){h(null,i)},function(h,m,$){a(h,function(Y,fe){if(Y)$(Y);else{var x=n({},t,fe),H=null;x.origin&&typeof x.origin=="function"?H=x.origin:x.origin&&(H=function(L,_){_(null,x.origin)}),H?H(h.headers.origin,function(L,_){L||!_?$(L):(x.origin=_,T(x,h,m,$))}):$()}})}}me.exports=P})()});var Ce={};Ve(Ce,{AskUI:()=>B,BadState:()=>f,DatabaseError:()=>v,Directions:()=>V,ISPDemoServer:()=>Q,InvalidArgument:()=>S,InvalidFile:()=>C,NotFound:()=>U,NotImplemented:()=>g,Process:()=>k,ProcessFile:()=>b,ProcessHandler:()=>O,ProcessStep:()=>I,ProcessingError:()=>D,ProcessingSystem:()=>F,SystemError:()=>z,TextFileProcessHandler:()=>W,defaultConnector:()=>X,router:()=>G});module.exports=Ae(Ce);var D=class extends Error{},C=class extends D{},S=class extends D{},f=class extends D{},g=class extends D{},U=class extends D{},v=class extends D{},z=class extends D{},B=class extends Error{constructor(t){super("Need more information from UI.");this.element=t}};var ee=A(require("csv-parse"));var O=class{constructor(e){this.name=e}connect(e){this.system=e}canHandle(e){throw new g(`A handler '${this.name}' cannot check file '${e.name}', since canHandle() is not implemented.`)}canAppend(e){throw new g(`A handler '${this.name}' cannot append file '${e.name}', since canAppend() is not implemented.`)}checkCompletion(e){throw new g(`A handler '${this.name}' cannot check state '${JSON.stringify(e)}', since checkCompletion() is not implemented.`)}async action(e,t,s,r){throw new g(`A handler '${this.name}' for files ${r.map(o=>`'${o}''`).join(", ")} does not implement action()`)}startingState(e){throw new g(`A handler '${this.name}' for file ${e.map(t=>`'${t}''`).join(", ")} does not implement startingState()`)}async getDirections(e,t){throw new g(`A handler '${this.name}' for state '${JSON.stringify(e)}' does not implement getDirections()`)}async rollback(e){throw new g(`A handler '${this.name}' for step '${e}' does not implement rollback()`)}};var E=require("interactive-elements"),W=class extends O{startingState(e){let t={};for(let s of e)t[s.name]={lines:s.decode().replace(/\n+$/,"").split(`
`).map((r,o)=>({text:r,line:o,columns:{}}))};return{stage:"initial",files:t}}checkCompletion(e){if(e.stage==="executed")return!0}async needInputForSegmentation(e,t){return!1}async needInputForClassification(e,t){return!1}async needInputForAnalysis(e,t){return!1}async needInputForExecution(e,t){return!1}async getDirections(e,t){let s,r;switch(e.stage){case"initial":if(s=await this.needInputForSegmentation(e,t),s)return s;r=new V({type:"action",action:{op:"segmentation"}});break;case"segmented":if(s=await this.needInputForClassification(e,t),s)return s;r=new V({type:"action",action:{op:"classification"}});break;case"classified":if(s=await this.needInputForAnalysis(e,t),s)return s;r=new V({type:"action",action:{op:"analysis"}});break;case"analyzed":if(s=await this.needInputForExecution(e,t),s)return s;r=new V({type:"action",action:{op:"execution"}});break;default:throw new f("Cannot find directions from the current state.")}return r}async action(e,t,s,r){if(!(0,E.isImportAction)(t))throw new f(`Action is not import action ${JSON.stringify(t)}`);if((0,E.isImportOpAction)(t))switch(t.op){case"analysis":case"classification":case"segmentation":case"execution":return this[t.op](e,s,r,e.config);default:throw new f(`Cannot parse action ${JSON.stringify(t)}`)}if((0,E.isImportConfigureAction)(t)&&(Object.assign(e.config,t.configure),await e.save()),(0,E.isImportAnswerAction)(t)){e.config.answers||(e.config.answers={});let o=e.config.answers;for(let c of Object.keys(t.answer)){o[c]=o[c]||{};for(let d of Object.keys(t.answer[c]))o[c][d]=t.answer[c][d]}await e.save()}return s}async segmentation(e,t,s,r){throw new g(`A class ${this.constructor.name} does not implement segmentation().`)}async classification(e,t,s,r){throw new g(`A class ${this.constructor.name} does not implement classification().`)}async analysis(e,t,s,r){throw new g(`A class ${this.constructor.name} does not implement analysis().`)}async execution(e,t,s,r){throw new g(`A class ${this.constructor.name} does not implement execution().`)}async parseLine(e,t={}){return new Promise((s,r)=>{(0,ee.default)(e,{delimiter:t.columnSeparator||",",skip_lines_with_error:!!t.skipErrors},function(o,c){o?r(o):s(c[0])})})}async parseCSV(e,t={}){let s=[],r=t.cutFromBeginning||0,o=!0;for(let d of Object.keys(e.files))for(let w=0;w<e.files[d].lines.length;w++){if(r){r--;continue}let y={...e.files[d].lines[w]},p=t.trimLines?y.text.trim():y.text;if(o)if(o=!1,t.useFirstLineHeadings){s=await this.parseLine(p,t);let P={};for(let i=0;i<s.length;i++)P[s[i]]=P[s[i]]||0,P[s[i]]++,P[s[i]]>1&&(s[i]=`${s[i]}${P[s[i]]}`);continue}else{let P=(await this.parseLine(p,t)).length;for(let i=0;i<P;i++)s.push(`${i}`)}let u={},T=p.trim()!==""?await this.parseLine(p,t):null;T&&(T.forEach((P,i)=>{i<s.length?u[s[i]]=P:(u["+"]=u["+"]||"",u["+"]+=P+`
`)}),y.columns=u,e.files[d].lines[w]=y)}return{...e,stage:"segmented"}}};var V=class{constructor(e){this.type=e.type,this.element=e.element,this.action=e.action}toJSON(){let e={type:this.type};return this.element&&(e.element=this.element),this.action&&(e.action=this.action),e}isImmediate(){return this.type==="action"}isComplete(){return this.type==="complete"}};var R=A(require("clone"));var te=A(require("chardet")),se=A(require("clone"));var b=class{constructor(e){this.id=null,this.processId=e.processId||null,this.name=e.name,this.type=e.type,this.encoding=e.encoding,this.data=e.data,this._decoded=void 0}toString(){return`ProcessFile #${this.id} ${this.name}`}toJSON(){return{processId:this.processId,name:this.name,type:this.type,encoding:this.encoding,data:this.data}}async save(e){let t=this.toJSON();if(this.encoding==="json"&&(t.data=JSON.stringify(t.data)),this.id)return await e("process_files").update(t).where({id:this.id}),this.id;if(this.id=(await e("process_files").insert(t).returning("id"))[0].id,this.id)return this.id;throw new v(`Saving process ${JSON.stringify(t)} failed.`)}firstLineMatch(e){let t=this.decode(),s=t.indexOf(`
`),r=s<0?t:t.substr(0,s).trim();return e.test(r)}secondLineMatch(e){let t=this.decode().split(`
`);return t.length>1&&e.test(t[1].trim())}thirdLineMatch(e){let t=this.decode().split(`
`);return t.length>2&&e.test(t[2].trim())}isTextFile(){return this.type?.startsWith("text/")||!1}parseEncoding(e){switch(e.toUpperCase()){case"UTF-8":return"utf-8";case"ISO-8859-1":return"latin1";case"UTF-16LE":return"utf16le";default:throw new C(`Not able to map text encoding ${e}.`)}}decode(){if(this._decoded)return this._decoded;switch(this.encoding){case"base64":let e=Buffer.from(this.data,"base64"),t=te.default.detect(e);if(!t)throw new C(`Cannot determine encoding for '${this}'.`);return this._decoded=e.toString(this.parseEncoding(t)),this._decoded;case"utf-8":return this._decoded=(0,se.default)(this.data),this._decoded;default:throw new C(`An encoding '${this.encoding}' is not yet supported.`)}}};var I=class{constructor(e){this.processId=e.processId||null,this.number=e.number,this.state=e.state,this.handler=e.handler,this.directions=e.directions?new V(e.directions):void 0,this.action=e.action,this.started=e.started,this.finished=e.finished}toString(){return`ProcessStep ${this.number} of Process #${this.processId}`}get db(){return this.process.db}async save(){if(this.id)return await this.db("process_steps").update(this.toJSON()).where({id:this.id}),this.id;if(this.started=new Date,this.id=(await this.db("process_steps").insert(this.toJSON()).returning("id"))[0].id,this.id)return this.id;throw new v(`Saving process ${JSON.stringify(this.toJSON)} failed.`)}toJSON(){return{processId:this.processId,number:this.number,state:this.state,directions:this.directions,handler:this.handler,action:this.action,started:this.started,finished:this.finished}}async setDirections(e,t){this.directions=t,await e("process_steps").update({directions:t.toJSON()}).where({id:this.id})}};var k=class{constructor(e,t,s={}){this.system=e,this.id=null,this.config=s,this.name=t||"[no name]",this.complete=!1,this.successful=void 0,this.files=[],this.steps=[],this.currentStep=void 0,this.status="INCOMPLETE"}toString(){return`Process #${this.id} ${this.name}`}toJSON(){return{name:this.name,config:this.config,complete:this.complete,successful:this.successful,currentStep:this.currentStep,status:this.status,error:this.error}}addFile(e){e.processId=this.id,this.files.push(e)}async addStep(e){e.processId=this.id,e.process=this,this.steps.push(e)}async getCurrentStep(){if(this.currentStep===null||this.currentStep===void 0)throw new f(`Process #${this.id} ${this.name} has invalid current step.`);return this.steps[this.currentStep]?this.steps[this.currentStep]:this.loadStep(this.currentStep)}async proceedToState(e,t){let s=await this.getCurrentStep(),r=this.system.getHandler(s.handler);s.action=e,s.finished=new Date,s.save();let o=new I({number:s.number+1,state:t,handler:r.name});this.addStep(o),this.currentStep=(this.currentStep||0)+1,this.system.logger.info(`Proceeding ${this} to new step ${this.currentStep}.`),this.save(),await o.save(),await this.system.checkFinishAndFindDirections(r,o)}get db(){return this.system.db}async save(){if(this.id)return await this.db("processes").update(this.toJSON()).where({id:this.id}),this.id;if(this.id=(await this.db("processes").insert(this.toJSON()).returning("id"))[0].id,this.id)return this.id;throw new v(`Saving process ${JSON.stringify(this.toJSON)} failed.`)}async load(e){let t=await this.db("processes").select("*").where({id:e}).first();if(!t)throw new S(`Cannot find process #${e}`);Object.assign(this,t),this.id=e,this.files=(await this.db("process_files").select("*").where({processId:this.id})).map(s=>{let r=new b(s);return r.id=s.id,r}),await this.getCurrentStep()}async loadStep(e){if(!this.id)throw new f(`Cannot load steps, if the process have no ID ${JSON.stringify(this.toJSON())}.`);if(this.currentStep===void 0)throw new f(`Cannot load any steps, since process have no current step ${JSON.stringify(this.toJSON())}.`);let t=await this.db("process_steps").where({processId:this.id,number:e}).first();if(!t)throw new f(`Cannot find step ${this.currentStep} for process ${JSON.stringify(this.toJSON())}.`);return this.steps[this.currentStep]=new I(t),this.steps[this.currentStep].id=t.id,this.steps[this.currentStep].process=this,this.steps[this.currentStep]}canRun(){return!this.complete&&(this.status==="INCOMPLETE"||this.status==="WAITING")}async run(){let e,t=100;for(;;){if(t--,t<0){this.system.logger.error(`Maximum number of executions reached for the process ${this}.`);break}if(e=await this.getCurrentStep(),!e.directions){this.system.logger.info(`No new directions for the process ${this}.`);break}if(!e.directions.isImmediate()){this.system.logger.info(`Waiting for more input for the process ${this}.`),await this.updateStatus();break}let s=this.system.getHandler(e.handler),r=(0,R.default)(e.state),o=(0,R.default)(e.directions.action);try{if(o){let c=await s.action(this,o,r,this.files);await this.proceedToState(o,c)}else throw new f(`Process step ${e} has no action.`)}catch(c){return await this.crashed(c)}}}async crashed(e){if("element"in e){let t=new V({type:"ui",element:e.element}),s=await this.getCurrentStep();s.directions=t,await s.save(),await this.updateStatus();return}if(this.system.logger.error(`Processing of ${this} failed:`,e),this.currentStep!==void 0&&this.currentStep!==null){let t=await this.loadStep(this.currentStep);t.finished=new Date,await t.save()}this.error=e.stack?e.stack:`${e.name}: ${e.message}`,await this.save(),await this.updateStatus()}async updateStatus(){let e="INCOMPLETE";if(this.error)e="CRASHED";else{if(this.currentStep===null||this.currentStep===void 0)throw new f(`Cannot check status when there is no current step loaded for ${this}`);let t=this.steps[this.currentStep];t.finished&&(this.successful===!0&&(e="SUCCEEDED"),this.successful===!1&&(e="FAILED")),t.directions&&(e=t.directions.isImmediate()?"INCOMPLETE":"WAITING")}switch(this.status!==e&&this.system.logger.info(`Process ${this} is now ${e}`),this.status=e,await this.db("processes").update({status:e}).where({id:this.id}),e){case"SUCCEEDED":await this.system.connector.success(this.state);break;case"CRASHED":await this.system.connector.fail(this.error);break;case"FAILED":await this.system.connector.fail(this.state);break;default:let t=this.currentStep?this.steps[this.currentStep].directions:null,s=this.currentStep?this.steps[this.currentStep].state:null;await this.system.connector.waiting(s,t)}}get state(){if(this.currentStep===null||this.currentStep===void 0)throw new f(`Cannot check state when there is no current step loaded for ${this}`);return this.steps[this.currentStep].state}async input(e){let t=await this.getCurrentStep(),s=this.system.getHandler(t.handler),r;try{r=await s.action(this,e,(0,R.default)(t.state),this.files)}catch(o){return this.crashed(o)}await this.proceedToState(e,r)}async rollback(){if(this.currentStep===null||this.currentStep===void 0)throw new f("Cannot roll back when there is no current step.");if(this.currentStep<1)throw new f("Cannot roll back when there is only initial step in the process.");let e=await this.getCurrentStep();if(this.system.logger.info(`Attempt of rolling back '${e}' from '${this}'.`),await this.system.getHandler(e.handler).rollback(e)){this.error&&(this.error=void 0),await this.db("process_steps").delete().where({id:e.id}),this.currentStep--,await this.save();let r=await this.getCurrentStep();return r.finished=void 0,await r.save(),await this.updateStatus(),this.system.logger.info(`Roll back of '${this}' to '${r}' successful.`),!0}return this.system.logger.info(`Not able to roll back '${this}'.`),!1}};var X={async initialize(){console.log(new Date,"Connector initialized.")},async applyResult(){return console.log(new Date,"Result received."),{}},async success(){console.log(new Date,"Process completed.")},async waiting(){},async fail(){console.error(new Date,"Process failed.")},async getTranslation(n){return n}};var F=class{constructor(e,t){this.handlers={};this.db=e,this.logger={info:(...s)=>console.log(new Date,...s),error:(...s)=>console.error(new Date,...s)},this.connector=t}async getTranslation(e,t){return this.connector.getTranslation(e,t)}register(e){if(!e)throw new S("A handler was undefined.");if(!e.name)throw new S("A handler without name cannot be registered.");if(e.name in this.handlers)throw new S(`The handler '${e.name}' is already defined.`);if(e.name.length>32)throw new S(`The handler name '${e.name}' is too long.`);e.system=this,this.handlers[e.name]=e}async createProcess(e,t,s){let r=new k(this,e,s);if(await r.save(),t.length<1)return await r.crashed(new S("No files given to create a process.")),r;let o=t[0],c=new b(o);r.addFile(c),await c.save(this.db);let d=null;for(let p of Object.values(this.handlers))try{if(p.canHandle(c)){d=p;break}}catch(u){return await r.crashed(u),r}if(!d)return await r.crashed(new S(`No handler found for the file ${o.name} of type ${o.type}.`)),r;for(let p=1;p<t.length;p++){let u=new b(t[p]);if(!d.canAppend(u))return await r.crashed(new S(`The file ${t[p].name} of type ${t[p].type} cannot be appended to handler.`)),r;r.addFile(u),await u.save(this.db)}let w;try{w=d.startingState(r.files)}catch(p){return await r.crashed(p),r}let y=new I({number:0,handler:d.name,state:w});return r.addStep(y),await y.save(),r.currentStep=0,await r.save(),this.logger.info(`Created process ${r}.`),await this.checkFinishAndFindDirections(d,y),r}async checkFinishAndFindDirections(e,t){let s;try{s=e.checkCompletion(t.state)}catch(r){return t.process.crashed(r)}if(s===void 0){let r;try{r=await e.getDirections(t.state,t.process.config)}catch(o){return t.process.crashed(o)}await t.setDirections(this.db,r)}else t.directions=void 0,t.action=void 0,t.finished=new Date,await t.save(),t.process.complete=!0,t.process.successful=s,await t.process.save();await t.process.updateStatus()}getHandler(e){if(!(e in this.handlers))throw new S(`There is no handler for '${e}'.`);return this.handlers[e]}async loadProcess(e){let t=new k(this,null);return await t.load(e),t}};var ne=A(require("express"));function re(n){return{process:{getAll:async()=>n("processes").select("*").orderBy("created","desc"),get:async e=>{let t=await n("processes").select("*").where({id:e}).first();if(t){let s=await n("process_steps").select("id","action","directions","number","started","finished").where({processId:e}).orderBy("number");t.steps=s||[]}return t},getStep:async(e,t)=>await n("process_steps").select("*").where({processId:e,number:t}).first()}}}function G(n,e){let t=ne.default.Router(),s=re(n);return t.get("/",async(r,o)=>o.send(await s.process.getAll())),t.get("/:id",async(r,o)=>o.send(await s.process.get(parseInt(r.params.id)))),t.post("/",async(r,o)=>{let c=e(r),{files:d,config:w}=r.body,y=d.map(u=>u.name),p=await c.createProcess(`Uploading files ${y.join(", ")}`,d,{...o.locals.server.configDefaults,...w});return p.canRun()&&await p.run(),o.send(await s.process.get(p.id))}),t.post("/:id",async(r,o)=>{let c=e(r),{id:d}=r.params,w=await c.loadProcess(parseInt(d));await w.input(r.body),w.canRun()&&await w.run(),o.sendStatus(204)}),t.get("/:id/step/:number",async(r,o)=>o.send(await s.process.getStep(parseInt(r.params.id),parseInt(r.params.number)))),t}var N=A(require("path")),Z=A(require("express")),J=A(require("fs")),he=A(require("knex")),ue=A(pe());var Q=class{constructor(e,t,s,r=null,o={}){this.app=(0,Z.default)();this.start=async(e=!1)=>{e&&await this.db.migrate.rollback(),await this.db.migrate.latest();let t=()=>{let s=new F(this.db,this.connector);return this.handlers.forEach(r=>s.register(r)),s};this.app.use((s,r,o)=>{r.locals.server=this,o()}),this.app.use((s,r,o)=>{console.log(new Date,s.method,s.url),o()}),this.app.use((0,ue.default)()),this.app.use(Z.default.json({limit:"1024MB"})),this.app.use("/api/isp",G(this.db,t)),this.server=this.app.listen(this.port,()=>{console.log(new Date,`Server started on port ${this.port}.`),this.connector.initialize(this)}),this.server.on("error",s=>{console.error(new Date,s)})};this.stop=async(e=void 0)=>{console.log(new Date,"Stopping the server."),await this.server.close(()=>{if(e)throw e;process.exit()})};this.port=e,this.configDefaults=o;let c=N.default.normalize(`${__dirname}/migrations/01_init.js`);if(J.default.existsSync(c)||(c=N.default.normalize(`${__dirname}/../../dist/migrations/01_init.js`)),J.default.existsSync(c)||(c=N.default.normalize(`${__dirname}/../../../dist/migrations/01_init.js`)),!J.default.existsSync(c))throw console.log(__dirname),new Error(`Cannot XXX find migrations file '${c}'.`);this.db=(0,he.default)({client:"pg",connection:t,migrations:{directory:N.default.dirname(c)}}),this.handlers=s,r?this.connector=r:this.connector=X}async lastProcessID(){let e=await this.db("processes").max("id").first();return e?e.max:null}};0&&(module.exports={AskUI,BadState,DatabaseError,Directions,ISPDemoServer,InvalidArgument,InvalidFile,NotFound,NotImplemented,Process,ProcessFile,ProcessHandler,ProcessStep,ProcessingError,ProcessingSystem,SystemError,TextFileProcessHandler,defaultConnector,router});
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
